/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_REF_PTR
#define OSG_REF_PTR 1

#include <osg/Config>
#include <type_traits>

namespace osg {

template<typename T> class observer_ptr;

/** Smart pointer for handling referenced counted objects.*/
template<class T>
class ref_ptr
{
    public:
        using value_type = T;
        using pointer = std::add_pointer_t<T>;
        using const_pointer = std::add_pointer_t<const T>;
        using reference = std::add_lvalue_reference_t<T>;
        using const_reference = std::add_lvalue_reference_t<const T>;
        // enable use as a pointer-like iterator
        using difference_type = std::ptrdiff_t;

        ref_ptr() noexcept : _ptr(nullptr) {}
        ref_ptr(pointer ptr) noexcept : _ptr(ptr) { if (_ptr != nullptr) _ptr->ref(); }
        ref_ptr(const ref_ptr& rp) noexcept : _ptr(rp._ptr) { if (_ptr != nullptr) _ptr->ref(); }
        ref_ptr(ref_ptr&& rp) noexcept : _ptr(rp._ptr) { rp._ptr = nullptr; }

        template<class Other> ref_ptr(const ref_ptr<Other>& rp) noexcept : _ptr(rp._ptr) { if (_ptr != nullptr) _ptr->ref(); }
        ref_ptr(observer_ptr<T>& optr) noexcept : _ptr(nullptr) { optr.lock(*this); }
        ~ref_ptr() noexcept { if (_ptr != nullptr) _ptr->unref();  _ptr = nullptr; }

        ref_ptr& operator = (const ref_ptr& rp) noexcept { assign(rp); return *this; }

        template<class Other> ref_ptr& operator = (const ref_ptr<Other>& rp) noexcept { assign(rp); return *this; }

        template<class Other> ref_ptr& operator = (ref_ptr<Other>&& rp) noexcept
        {
            if (_ptr == rp._ptr) return *this;
            if (_ptr != nullptr) _ptr->unref();
            _ptr = rp._ptr;
            rp._ptr = nullptr;
            return *this;
        }

        inline ref_ptr& operator = (pointer ptr) noexcept
        {
            if (_ptr==ptr) return *this;
            pointer tmp_ptr = _ptr;
            _ptr = ptr;
            if (_ptr != nullptr) _ptr->ref();
            // unref second to prevent any deletion of any object which might
            // be referenced by the other object. i.e rp is child of the
            // original _ptr.
            if (tmp_ptr) tmp_ptr->unref();
            return *this;
        }

        explicit operator bool() const noexcept { return _ptr != nullptr; }
        bool operator!() const noexcept { return _ptr == nullptr; } // not required
        
        bool operator==(const ref_ptr& rp) const noexcept { return _ptr == rp._ptr; }
        bool operator!=(const ref_ptr& rp) const noexcept { return _ptr != rp._ptr; }
        bool operator<(const ref_ptr& rp) const noexcept { return _ptr < rp._ptr; }
        bool operator<=(const ref_ptr& rp) const noexcept { return _ptr <= rp._ptr; }
        bool operator>(const ref_ptr& rp) const noexcept { return _ptr > rp._ptr; }
        bool operator>=(const ref_ptr& rp) const noexcept { return _ptr >= rp._ptr; }

        bool operator==(const_pointer ptr) const noexcept { return _ptr == ptr; }
        bool operator!=(const_pointer ptr) const noexcept { return _ptr != ptr; }
        bool operator<(const_pointer ptr) const noexcept { return _ptr < ptr; }
        bool operator<=(const_pointer ptr) const noexcept { return _ptr <= ptr; }
        bool operator>(const_pointer ptr) const noexcept { return _ptr > ptr; }
        bool operator>=(const_pointer ptr) const noexcept { return _ptr >= ptr; }

        friend bool operator==(const_pointer ptr, const ref_ptr& rp) noexcept { return ptr == rp._ptr; }
        friend bool operator!=(const_pointer ptr, const ref_ptr& rp) noexcept { return ptr != rp._ptr; }
        friend bool operator<(const_pointer ptr, const ref_ptr& rp) noexcept { return ptr < rp._ptr; }
        friend bool operator<=(const_pointer ptr, const ref_ptr & rp) noexcept { return ptr <= rp._ptr; }
        friend bool operator>(const_pointer ptr, const ref_ptr& rp) noexcept { return ptr > rp._ptr; }
        friend bool operator>=(const_pointer ptr, const ref_ptr& rp) noexcept { return ptr >= rp._ptr; }

        reference operator*() const noexcept { return *_ptr; }
        pointer operator->() const noexcept { return _ptr; }

        pointer get() const noexcept { return _ptr; }

        bool valid() const noexcept { return _ptr!=nullptr; }

        /** release the pointer from ownership by this ref_ptr<>, decrementing the objects refencedCount() via unref_nodelete() to prevent the Object
          * object from being deleted even if the reference count goes to zero.  Use when using a local ref_ptr<> to an Object that you want to return
          * from a function/method via a C pointer, whilst preventing the normal ref_ptr<> destructor from cleaning up the object. When using release()
          * you are implicitly expecting other code to take over management of the object, otherwise a memory leak will result. */
        pointer release() noexcept { pointer tmp=_ptr; if (_ptr != nullptr) _ptr->unref_nodelete(); _ptr=nullptr; return tmp; }

        void swap(ref_ptr& rp) noexcept { pointer tmp=_ptr; _ptr=rp._ptr; rp._ptr=tmp; }

    private:

        template<class Other> void assign(const ref_ptr<Other>& rp) noexcept
        {
            if (_ptr==rp._ptr) return;
            pointer tmp_ptr = _ptr;
            _ptr = rp._ptr;
            if (_ptr != nullptr) _ptr->ref();
            // unref second to prevent any deletion of any object which might
            // be referenced by the other object. i.e rp is child of the
            // original _ptr.
            if (tmp_ptr) tmp_ptr->unref();
        }

        template<class Other> friend class ref_ptr;

        pointer _ptr;
};


template<class T> inline
void swap(ref_ptr<T>& rp1, ref_ptr<T>& rp2) { rp1.swap(rp2); }

template<class T> inline
T* get_pointer(const ref_ptr<T>& rp) { return rp.get(); }

template<class T, class Y> inline
ref_ptr<T> static_pointer_cast(const ref_ptr<Y>& rp) { return static_cast<ref_ptr::pointer>(rp.get()); }

template<class T, class Y> inline
ref_ptr<T> dynamic_pointer_cast(const ref_ptr<Y>& rp) { return dynamic_cast<ref_ptr::pointer>(rp.get()); }

template<class T, class Y> inline
ref_ptr<T> const_pointer_cast(const ref_ptr<Y>& rp) { return const_cast<ref_ptr::pointer>(rp.get()); }

}

#endif
